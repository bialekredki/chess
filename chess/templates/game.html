{%extends 'main.html'%}

{%block head%}
{{super()}}
<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/6.1.0-rc.6/browser/pixi.js"></script>
{%endblock%}

{%block scripts%}
{{super()}}
<script src="{{url_for('static', filename='js/game.js')}}"></script>
<script>
var socket = io();
    socket.on('connect', function() {
        console.log('Socket connected');
        socket.emit('getgame', {id:"{{game.id}}"});
        {%if current_user.id == game.host_id or current_user.id == game.guest_id%}
            socket.emit('getcolour' ,{id:"{{game.id}}", player_id:"{{current_user.id}}"}, namespace=`/g${"{{game.id}}"}`)
        {%endif%}
    });

    {%if current_user.id == game.host_id or current_user.id == game.guest_id%}
            socket.on('setcolour', (json) => {
                colour = json['colour'];
                console.log(json);
        });
    {%endif%}
    socket.on('setpossiblemoves', (json) => {
        json['moves'].forEach((move)=>{
            let tile = tiles[(7-move[0])*8+move[1]]
            tile.alpha = 0.5;
        });
    });
    socket.on('move', (json) =>{
        let to = json['to'];
        let from = json['from'];
        let tile = tiles[(7-to[0])*8+to[1]];
        let piece;
        for(let i = 0; i<sprites.length; i++){
            if(sprites[i].location[0] == from[0] && sprites[i].location[1] == from[1]){
                piece = sprites[i];
                break;
            }
        }
        move(piece, tile)
        piece.alpha = 1;
        app.lastObj = tile;
    });
    socket.on('setgame', (json)=>{
        json['tiles'].forEach((row,r)=>{
            row.forEach((col,c) => {
                game_state.at(r,c).piece = col['piece'];
                game_state.at(r,c).colour = col['colour'];
                game_state.at(r,c).moved = col['moved'];
            });
        });
        [tiles,sprites] = renderApp(app,game_state,textures)
    });


    getSpriteAt = (location) => {
        let piece = null;
        sprites.forEach(function(e) {
            if (e.location[0] == location[0] && e.location[1] == location[1]) {
                piece = e;
                return;
            }
        });
        return piece;
    }


    pieceOnDragBegin = (event) => {
        let target = event.target;
        if(target.objName == 'piece'){
            if(app.lastObj && app.lastObj.objName == 'piece'){
                app.lastObj.alpha = 1;
                tiles.forEach((tile)=>{
                    tile.alpha = 1;
                });
                if(game_state.at(app.lastObj.location[0], app.lastObj.location[1]).colour == colour && game_state.at(target.location[0], target.location[1]).colour != colour){
                    socket.emit('confirmmove', {
                        game: game_state,
                        to: target.location,
                        from: app.lastObj.location,
                        gameid: "{{game.id}}"
                    })
                    return;
                }
            }
            app.lastObj = target;
            target.alpha = 0.7;
            socket.emit('getpossiblemoves', {
                game: game_state,
                from: target.location,
                gameid: "{{game.id}}"
            })
        }
        if(target.objName == 'tile' && app.lastObj.objName == 'piece'){
            socket.emit('confirmmove', {
                game: game_state,
                to: target.location,
                from: app.lastObj.location,
                gameid: "{{game.id}}"
            })
        }
    }

    rowColToXY = (row,col,size_x,size_y) => {
        return [(7-row)*size_y,col*size_x];
    };

    removeSprite = (sprite) => {
        sprites = sprites.filter(function(value,index,array) {
            return (value.location[0] != sprite.location[0] && value.location[1] != sprite.location[1]);
        });
    }

    move = (piece,tile) => {
        let size_x = Math.floor(app.renderer.gl.drawingBufferWidth/8);
        let size_y = Math.floor(app.renderer.gl.drawingBufferHeight/8);
        let gs_tile_src = game_state.tiles[piece.location[0]][[piece.location[1]]];
        let gs_tile_dst = game_state.tiles[tile.location[0]][[tile.location[1]]];
        let taken_piece = getSpriteAt(tile.location);
        if(taken_piece != null){
            container.removeChild(taken_piece);
            removeSprite(taken_piece);
        }
        [y,x] = rowColToXY(tile.location[0], tile.location[1], size_x, size_y);
        piece.x = x + size_x/2;
        piece.y = y + size_y/2;
        gs_tile_dst.piece = gs_tile_src.piece;
        gs_tile_dst.colour = gs_tile_src.colour;
        gs_tile_dst.moved = true;
        gs_tile_src.piece = 0;
        gs_tile_src.colour = false;
        gs_tile_src.moved = false;
        piece.location = tile.location;
    }
    renderApp = (app, game,textures) => {
        let start_x = 0;
        let start_y = 0;
        let size_x = Math.floor(app.renderer.gl.drawingBufferWidth/8);
        let size_y = Math.floor(app.renderer.gl.drawingBufferHeight/8);
        let sprites = new Array();
        let tiles = new Array();
        
        for(let row = 7; row >= 0; row--){
            for(let col = 0; col < 8; col++){
                tiles.push(new PIXI.Graphics())
                if(row % 2 == col % 2)  tiles.at(-1).beginFill(white_tile);
                else 
                    tiles.at(-1).beginFill(black_tile);
                tiles.at(-1).drawRect(start_x,start_y, size_x, size_y);
                tiles.at(-1).endFill();
                tiles.at(-1).interactive = true;
                tiles.at(-1).objName = 'tile'
                tiles.at(-1).location = [row,col];
                tiles.at(-1).on('pointerdown', pieceOnDragBegin)
                if(game.isEmpty(row,col)) {
                    start_x += size_x;
                    continue;
                }
                let colour = 'w'
                if(game.isBlack(row,col)) colour = 'b';
                let name = `${colour}${game.getPiece(row,col, 'string')}`
                sprites.push(PIXI.Sprite.from(textures[name]));
                sprites.at(-1).anchor.set(0.5);
                sprites.at(-1).x = start_x + size_x / 2;
                sprites.at(-1).y = start_y + size_y / 2;
                sprites.at(-1).interactive = true;
                sprites.at(-1).buttonMode = true;
                sprites.at(-1).objName = 'piece';
                sprites.at(-1).colour = colour;
                sprites.at(-1).location = [row,col];
                sprites.at(-1) .on('pointerdown', pieceOnDragBegin)
                start_x += size_x;
            }
            start_y += size_y;
            start_x = 0;
        }
        tiles.forEach((tile)=> {
            container.addChild(tile);
        });
        sprites.forEach((sprite) => {
            container.addChild(sprite);
        });
        return [tiles, sprites];
    }

        const app = new PIXI.Application({
            width: 800,
            height: 600,
            backgroundColor: 0x000000,
            resolution: window.devicePixelRation || 1,
            antialias: true
        });
        $('#root').append(app.view);
        const container = new PIXI.Container();
        let tiles = Array()
        let sprites = Array()
        let game_state = new Game();
        let black_tile = 0x832f47;
        let white_tile = 0xdb9eaf;
        let white_tile_hinted = 0xf1dae2;
        let colour = null;
        

        let textures = {'bbishop': PIXI.Texture.from('/static/img/gfx/Chess_bdt60.png'),
        'wbishop': PIXI.Texture.from('/static/img/gfx/Chess_blt60.png'),
        'bpawn': PIXI.Texture.from('/static/img/gfx/Chess_pdt60.png'),
        'wpawn': PIXI.Texture.from('/static/img/gfx/Chess_plt60.png'),
        'bknight': PIXI.Texture.from('/static/img/gfx/Chess_ndt60.png'),
        'wknight': PIXI.Texture.from('/static/img/gfx/Chess_nlt60.png'),
        'brook': PIXI.Texture.from('/static/img/gfx/Chess_rdt60.png'),
        'wrook': PIXI.Texture.from('/static/img/gfx/Chess_rlt60.png'),
        'bqueen': PIXI.Texture.from('/static/img/gfx/Chess_qdt60.png'),
        'wqueen': PIXI.Texture.from('/static/img/gfx/Chess_qlt60.png'),
        'bking': PIXI.Texture.from('/static/img/gfx/Chess_kdt60.png'),
        'wking': PIXI.Texture.from('/static/img/gfx/Chess_klt60.png')}
        Object.entries(textures).forEach(([key,value]) => {
            value.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;
        })
        app.stage.addChild(container);

        
</script>
{%endblock%}

{%block sitecontent%}
<div id='black-user-banner'>
    <table class='table'>
    <thead></thead>
    <tbody>    
    {%if game.is_host_white%}
        {%set user=game.guest%}
    {%else%}
        {%set user=game.host%}
    {%endif%}
    {%if user != None%}
    {%include 'user/user_table_row.html'%}</tbody></table
    {%endif%}
</div>
<div id='root'>
</div>
    <table class='table'>
    <thead></thead>
    <tbody>    
    {%if game.is_host_white%}
        {%set user=game.host%}
    {%else%}
        {%set user=game.guest%}
    {%endif%}
    {%if user != None%}
    {%include 'user/user_table_row.html'%}</tbody></table
    {%endif%}
{%endblock%}

